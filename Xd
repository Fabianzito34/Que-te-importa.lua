
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local SilentAimSettings = {
    Enabled = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    TeamCheck = false,
    VisibleCheck = false,
    HitChance = 100,
    PredictionAmount = 0.165,
    ShowFOV = false,
    ShowTargetBox = false
}

local ValidTargetParts = {"Head", "HumanoidRootPart"}

local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 0.5
fov_circle.Color = Color3.fromRGB(54, 57, 241)

local mouse_box = Drawing.new("Square")
mouse_box.Thickness = 2
mouse_box.Size = Vector2.new(20, 20)
mouse_box.Filled = false
mouse_box.Visible = false
mouse_box.ZIndex = 999
mouse_box.Color = Color3.fromRGB(54, 57, 241)

local function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
    return chance <= Percentage / 100
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = Camera:WorldToScreenPoint(Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    
    if not (PlayerCharacter and LocalPlayerCharacter) then return false end 
    
    local PlayerRoot = PlayerCharacter:FindFirstChild("HumanoidRootPart")
    
    if not PlayerRoot then return false end 
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {LocalPlayerCharacter, PlayerCharacter}
    
    local rayResult = workspace:Raycast(Camera.CFrame.Position, (PlayerRoot.Position - Camera.CFrame.Position).Unit * 1000, raycastParams)
    
    return rayResult and rayResult.Instance and rayResult.Instance:IsDescendantOf(PlayerCharacter)
end

local function getClosestPlayer()
    local ClosestTarget = nil
    local SmallestDistance = math.huge
    local MousePosition = UserInputService:GetMouseLocation()

    for _, Player in ipairs(Players:GetPlayers()) do
        if Player == LocalPlayer then continue end
        if SilentAimSettings.TeamCheck and Player.Team == LocalPlayer.Team then continue end

        local Character = Player.Character
        if not Character then continue end
        
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if not Humanoid or Humanoid.Health <= 0 then continue end

        local targetPart = nil
        if SilentAimSettings.TargetPart == "Random" then
            targetPart = Character:FindFirstChild(ValidTargetParts[math.random(1, #ValidTargetParts)])
        else
            targetPart = Character:FindFirstChild(SilentAimSettings.TargetPart)
        end
        
        if not targetPart then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(targetPart.Position)
        if not OnScreen then continue end

        local Distance = (MousePosition - ScreenPosition).Magnitude
        if Distance <= SilentAimSettings.FOVRadius then
            if SilentAimSettings.VisibleCheck and not IsPlayerVisible(Player) then continue end
            
            if Distance < SmallestDistance then
                SmallestDistance = Distance
                ClosestTarget = targetPart
            end
        end
    end
    return ClosestTarget
end

local Window = Fluent:CreateWindow("VIXC 3 Silent Aim")

local MainTab = Window:AddTab("Principal")

local MainSection = MainTab:AddSection("Configuración General")

MainSection:AddToggle("EnabledToggle")
    :SetName("Habilitar Silent Aim")
    :SetValue(SilentAimSettings.Enabled)
    :OnChanged(function(value)
        SilentAimSettings.Enabled = value
    end)

MainSection:AddDropdown("TargetPartDropdown")
    :SetName("Parte del Objetivo")
    :SetDescription("Elige la parte del cuerpo a la que apuntará el Silent Aim.")
    :AddOption("Head")
    :AddOption("HumanoidRootPart")
    :AddOption("Random")
    :SetValue(SilentAimSettings.TargetPart)
    :OnChanged(function(value)
        SilentAimSettings.TargetPart = value
    end)

MainSection:AddDropdown("MethodDropdown")
    :SetName("Método de Silent Aim")
    :SetDescription("Selecciona el método de detección para el Silent Aim.")
    :AddOption("Raycast")
    :AddOption("FindPartOnRay")
    :AddOption("Mouse.Hit")
    :SetValue(SilentAimSettings.SilentAimMethod)
    :OnChanged(function(value)
        SilentAimSettings.SilentAimMethod = value
    end)

MainSection:AddToggle("TeamCheckToggle")
    :SetName("Verificación de Equipo")
    :SetValue(SilentAimSettings.TeamCheck)
    :OnChanged(function(value)
        SilentAimSettings.TeamCheck = value
    end)

MainSection:AddToggle("VisibleCheckToggle")
    :SetName("Verificación de Visibilidad")
    :SetValue(SilentAimSettings.VisibleCheck)
    :OnChanged(function(value)
        SilentAimSettings.VisibleCheck = value
    end)

local AdjustmentsSection = MainTab:AddSection("Ajustes Fino")

AdjustmentsSection:AddSlider("FOVRadiusSlider")
    :SetName("Radio de FOV")
    :SetDescription("Define el radio del campo de visión para encontrar objetivos.")
    :SetMin(0)
    :SetMax(360)
    :SetUnit("px")
    :SetValue(SilentAimSettings.FOVRadius)
    :OnChanged(function(value)
        SilentAimSettings.FOVRadius = value
    end)

AdjustmentsSection:AddSlider("HitChanceSlider")
    :SetName("Probabilidad de Impacto")
    :SetDescription("Porcentaje de posibilidades de que el Silent Aim funcione.")
    :SetMin(0)
    :SetMax(100)
    :SetUnit("%")
    :SetValue(SilentAimSettings.HitChance)
    :OnChanged(function(value)
        SilentAimSettings.HitChance = value
    end)

AdjustmentsSection:AddSlider("PredictionAmountSlider")
    :SetName("Cantidad de Predicción")
    :SetDescription("Ajusta la predicción de movimiento para el método Mouse.Hit.")
    :SetMin(0)
    :SetMax(1)
    :SetUnit("s")
    :SetValue(SilentAimSettings.PredictionAmount)
    :SetRounding(3)
    :OnChanged(function(value)
        SilentAimSettings.PredictionAmount = value
    end)

local VisualsTab = Window:AddTab("Visuales")
local VisualsSection = VisualsTab:AddSection("Opciones Visuales")

VisualsSection:AddToggle("ShowFOVToggle")
    :SetName("Mostrar Círculo FOV")
    :SetValue(SilentAimSettings.ShowFOV)
    :OnChanged(function(value)
        SilentAimSettings.ShowFOV = value
    end)

VisualsSection:AddToggle("ShowTargetBoxToggle")
    :SetName("Mostrar Caja de Objetivo")
    :SetValue(SilentAimSettings.ShowTargetBox)
    :OnChanged(function(value)
        SilentAimSettings.ShowTargetBox = value
    end)

RunService.RenderStepped:Connect(function()
    if SilentAimSettings.ShowFOV then
        fov_circle.Visible = true
        fov_circle.Radius = SilentAimSettings.FOVRadius
        fov_circle.Position = UserInputService:GetMouseLocation()
    else
        fov_circle.Visible = false
    end

    if SilentAimSettings.ShowTargetBox and SilentAimSettings.Enabled then
        local closestPlayer = getClosestPlayer()
        if closestPlayer then
            local rootPart = closestPlayer.Parent:FindFirstChild("HumanoidRootPart") or closestPlayer
            if rootPart then
                local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                if onScreen then
                    mouse_box.Visible = true
                    mouse_box.Position = Vector2.new(screenPos.X, screenPos.Y)
                else
                    mouse_box.Visible = false
                end
            else
                mouse_box.Visible = false
            end
        else
            mouse_box.Visible = false
        end
    else
        mouse_box.Visible = false
    end
end)

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]

    if SilentAimSettings.Enabled and self == workspace and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then
        local HitPart = getClosestPlayer()
        if HitPart then
            if Method == "FindPartOnRay" or Method == "findPartOnRay" then
                if SilentAimSettings.SilentAimMethod == "FindPartOnRay" then
                    local A_Ray = Arguments[2]
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                end
            elseif Method == "Raycast" then
                if SilentAimSettings.SilentAimMethod == "Raycast" then
                    local A_Origin = Arguments[2]
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)
                    return oldNamecall(unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(...)
end))

local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() and SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Mouse.Hit" and CalculateChance(SilentAimSettings.HitChance) then
        local HitPart = getClosestPlayer()
        if HitPart then
            if Index == "Target" or Index == "target" then
                return HitPart
            elseif Index == "Hit" or Index == "hit" then
                local predictedCFrame = HitPart.CFrame
                if SilentAimSettings.PredictionAmount > 0 and HitPart:IsA("BasePart") then
                    predictedCFrame = predictedCFrame + (HitPart.Velocity * SilentAimSettings.PredictionAmount)
                end
                return predictedCFrame
            end
        end
    end
    return oldIndex(self, Index)
end))
